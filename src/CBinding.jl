module CBinding
	import Libdl
	
	
	export @ctypedef, @cstruct, @cunion, @carray, @calign, @cenum, @cextern, @cbindings, @ccallback
	export Clongdouble, Cbool, Caggregate, Cstruct, Cunion, Carray, Cenum, Clibrary, Cglobal, Cglobalconst, Cfunction, Cconvention, Calignment, Cconst, Caccessor
	export STDCALL, CDECL, FASTCALL, THISCALL
	export propertytypes
	
	
	# ğ£ğ¥ can be used in a baremodule to keep a clean namespace which avoids naming conflicts with auto-generated C bindings
	const ğ£ğ¥ = CBinding
	
	
	# provide a temporary placeholder for 128-bit floating point primitive
	primitive type Clongdouble <: AbstractFloat sizeof(Cdouble)*2*8 end
	
	const Cbool = Cuchar
	
	
	abstract type Cstruct end
	abstract type Cunion end
	const Caggregate = Union{Cstruct, Cunion}
	
	abstract type Cenum <: Integer end
	
	const Copaques = Union{Caggregate, Cenum}
	function Base.show(io::IO, ::Type{CO}) where {CO<:Copaques}
		if CO isa DataType
			return Base.show_datatype(io, isabstracttype(CO) ? CO : supertype(CO))
		end
		return invoke(show, Tuple{IO, Type}, io, CO)
	end
	
	struct Cconst{T, S}
		mem::NTuple{S, UInt8}
		
		Cconst{T}(x::NTuple{X, UInt8}) where {T, X} = new{T, sizeof(T)}(x)
	end
	
	# these are being generated by CBindingGen, but not really usable yet...
	Crestrict(::Type{T}) where {T} = T
	Cvolatile(::Type{T}) where {T} = T
	
	
	# alignment strategies
	struct Calignment{SymT}
	end
	
	const ALIGN_NATIVE = Calignment{:native}
	const ALIGN_PACKED = Calignment{:packed}
	
	
	# calling conventions
	struct Cconvention{SymT}
	end
	
	const STDCALL  = Cconvention{:stdcall}
	const CDECL    = Cconvention{:cdecl}
	const FASTCALL = Cconvention{:fastcall}
	const THISCALL = Cconvention{:thiscall}
	
	
	include("ctypespec.jl")
	include("clibrary.jl")
	include("cbindings.jl")
	include("cenum.jl")
	include("carray.jl")
	include("cconst.jl")
	include("caggregate.jl")
	include("cfunction.jl")
	include("cetc.jl")
	include("ctypelayout.jl")
	include("caccessor.jl")
	include("cglobal.jl")
end
